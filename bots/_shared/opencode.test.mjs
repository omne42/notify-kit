import assert from "node:assert/strict"
import { spawn } from "node:child_process"
import path from "node:path"
import { test } from "node:test"
import { fileURLToPath, pathToFileURL } from "node:url"

import { buildResponseText, withTimeout } from "./opencode.mjs"

const here = path.dirname(fileURLToPath(import.meta.url))
const opencodeModuleUrl = pathToFileURL(path.join(here, "opencode.mjs")).href

function runNodeScript(script) {
  return new Promise((resolve, reject) => {
    const child = spawn(process.execPath, ["--input-type=module", "-e", script], {
      stdio: ["ignore", "pipe", "pipe"],
    })

    let stdout = ""
    let stderr = ""
    child.stdout.on("data", (chunk) => {
      stdout += String(chunk)
    })
    child.stderr.on("data", (chunk) => {
      stderr += String(chunk)
    })
    child.on("error", reject)
    child.on("close", (code) => {
      resolve({ code, stdout, stderr })
    })
  })
}

test("runEventSubscriptionLoop retries when handler fails before concurrency cap", async () => {
  const script = `
import { runEventSubscriptionLoop } from ${JSON.stringify(opencodeModuleUrl)}

let subscribeCalls = 0
let first = true
console.error = () => {}

setTimeout(() => {
  console.log("SUBSCRIBE_CALLS=" + String(subscribeCalls))
  process.exit(0)
}, 400)

void runEventSubscriptionLoop({
  label: "test-loop",
  minBackoffMs: 10,
  maxBackoffMs: 10,
  jitterMs: 0,
  maxConcurrentOnEvent: 4,
  subscribe: async () => {
    subscribeCalls += 1
    return {
      stream: (async function* () {
        yield { id: 1 }
        if (first) {
          first = false
          await new Promise(() => {})
        }
      })(),
    }
  },
  onEvent: async () => {
    throw new Error("boom")
  },
})
`

  const { code, stdout, stderr } = await runNodeScript(script)
  assert.equal(code, 0, `child exited with non-zero code, stderr=${stderr}`)

  const match = stdout.match(/SUBSCRIBE_CALLS=(\d+)/)
  assert.ok(match, `missing subscribe count output, stdout=${stdout}`)
  const subscribeCalls = Number.parseInt(match[1], 10)
  assert.ok(Number.isFinite(subscribeCalls), `invalid subscribe count, stdout=${stdout}`)
  assert.ok(subscribeCalls >= 2, `expected loop retry, got subscribeCalls=${subscribeCalls}`)
})

test("runEventSubscriptionLoop does not leak pending next() rejection on handler failure", async () => {
  const script = `
import { runEventSubscriptionLoop } from ${JSON.stringify(opencodeModuleUrl)}

let subscribeCalls = 0
let unhandled = 0
console.error = () => {}
process.on("unhandledRejection", () => {
  unhandled += 1
})

setTimeout(() => {
  console.log("SUBSCRIBE_CALLS=" + String(subscribeCalls))
  console.log("UNHANDLED=" + String(unhandled))
  process.exit(0)
}, 450)

void runEventSubscriptionLoop({
  label: "test-loop-pending-next",
  minBackoffMs: 10,
  maxBackoffMs: 10,
  jitterMs: 0,
  maxConcurrentOnEvent: 4,
  subscribe: async () => {
    subscribeCalls += 1
    let step = 0
    return {
      stream: {
        [Symbol.asyncIterator]() {
          return this
        },
        next() {
          step += 1
          if (step === 1) return Promise.resolve({ done: false, value: { id: 1 } })
          return new Promise((_, reject) => {
            setTimeout(() => reject(new Error("late-next-fail")), 30)
          })
        },
        return() {
          return Promise.resolve({ done: true, value: undefined })
        },
      },
    }
  },
  onEvent: async () => {
    throw new Error("boom")
  },
})
`

  const { code, stdout, stderr } = await runNodeScript(script)
  assert.equal(code, 0, `child exited with non-zero code, stderr=${stderr}`)

  const subscribeMatch = stdout.match(/SUBSCRIBE_CALLS=(\d+)/)
  assert.ok(subscribeMatch, `missing subscribe count output, stdout=${stdout}`)
  const subscribeCalls = Number.parseInt(subscribeMatch[1], 10)
  assert.ok(Number.isFinite(subscribeCalls), `invalid subscribe count, stdout=${stdout}`)
  assert.ok(subscribeCalls >= 2, `expected loop retry, got subscribeCalls=${subscribeCalls}`)

  const unhandledMatch = stdout.match(/UNHANDLED=(\d+)/)
  assert.ok(unhandledMatch, `missing unhandled count output, stdout=${stdout}`)
  const unhandled = Number.parseInt(unhandledMatch[1], 10)
  assert.ok(Number.isFinite(unhandled), `invalid unhandled count, stdout=${stdout}`)
  assert.equal(unhandled, 0, `expected no unhandled rejections, stdout=${stdout}`)
})

test("buildResponseText prefers info content", () => {
  const out = buildResponseText({
    info: { content: "from-info" },
    parts: [{ type: "text", text: "from-part" }],
  })
  assert.equal(out, "from-info")
})

test("buildResponseText joins text parts with newline", () => {
  const out = buildResponseText({
    parts: [
      { type: "tool", text: "ignored" },
      { type: "text", text: "line-1" },
      { type: "text", text: "line-2" },
    ],
  })
  assert.equal(out, "line-1\nline-2")
})

test("buildResponseText keeps join semantics for empty text segments", () => {
  const out = buildResponseText({
    parts: [
      { type: "text" },
      { type: "text", text: "line-2" },
    ],
  })
  assert.equal(out, "\nline-2")
})

test("buildResponseText falls back when no text is available", () => {
  const out = buildResponseText({
    parts: [{ type: "tool", text: "ignored" }],
  })
  assert.equal(out, "I received your message but didn't have a response.")
})

test("withTimeout handles synchronous task throws as rejected promises", async () => {
  await assert.rejects(
    () =>
      withTimeout(() => {
        throw new Error("sync-boom")
      }, "sync-task", 100),
    /sync-boom/,
  )
})
